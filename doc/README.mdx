# ppx_template

<!--
set up mdx

```ocaml
# open Core;;
```
-->

Overview
--------

ppx_template emulates polymorphism by generating multiple copies of a given binding for
different parameters. For example, to write an identity function which works for all kinds
of unboxed numbers, one might write:

```ocaml
let%template id (type a : k) (x : a) = x
[@@kind k = (float32, float64, bits32, bits64)]
```

This generates four functions: `id__float32`, `id__float64`, `id__bits32`, and
`id__bits64`, which can be called by using the `[@kind]` attribute on an identifier:

```ocaml
let test x =
  [%test_result: float]
    (Float_u.to_float ((id [@kind float64]) (Float_u.of_float x)))
    ~expect:x
;;
```

Note that this attribute is not inside a `%template` extension point; this is allowed (but
not required) for improved readability. This works when instantiating a templated
function, while attributes that make a value polymorphic must always be inside an
extension point.

Kind polymorphism
-----------------

Multiple kinds can be specified using `[@@kind a = (l, m), b = (n, o)]` and `[@kind a b]`.
Mangled names are generated by appending `__%{kind}` to the identifier for each kind, with
one exception: when all kinds are `value`, the name is unchanged, i.e. exactly as it
appears in the source code. One binding is produced for each element of the cartesian
product of kind variable assignments, so for some hypothetical function:

```ocaml
let%template f (type (a : a) (b : b)) (x : a) (y : b) = #(x, y)
[@@kind a = (value, float64), b = (value, bits64)]
```

We would generate:

- `val f : ('a : value) ('b : value).  'a -> 'b -> _`
- `val f__value__bits64 : ('a : value) ('b : bits64).  'a -> 'b -> _`
- `val f__float64__value : ('a : float64) ('b : value).  'a -> 'b -> _`
- `val f__float64__bits64 : ('a : float64) ('b : bits64).  'a -> 'b -> _`

Which could be called via:

- `f [@kind value value]`
- `f [@kind value bits64]`
- `f [@kind float64 value]`
- `f [@kind float64 bits64]`

In addition to `let` and `val` bindings, `[@@kind]` also supports `module`, `module type`,
and `type` bindings, while `[@kind]` supports module names, module type names, and type
constructors.

Mode polymorphism
-----------------
In addition to kind polymorphism, ppx_template supports mode polymorphism, accessible via
the `[@@@mode]`, `[@@mode]`, and `[@mode]` attributes. They may appear in all the same
places in the AST as kinds, and bindings may be both kind- and mode-polymorphic.

Similar to kind annotations e.g. `type t : k [@@kind k]`, the ppx also understands how to
substitute mode variables e.g. `type t = u @ m -> u @ m [@@mode m]`.

We also support an additional attribute, `[@exclave_if_local m]`, where `m` is either a
mode variable bound previously by the ppx, or a built-in mode (e.g. `local`). This
attribute may only be attached to expressions. When generating bindings, the ppx will
check if `m = local`, and if so, wrap the expression in an `exclave_`.

To ensure that we will be able to natively support the full feature set of this ppx in the
compiler, we only permit `[@exclave_if_local]` to appear on two classes of expression:

- "Pure" syntactic allocations, such as tuples, records, or arrays
- Tailcalls involving only bound identifiers

Modality polymorphism
---------------------
Analagous to mode polymorphism, there is support for "modality polymorphism" (in quotes
as this isn't obviously a meaningful notion), along with the corresponding `[@@@modality]`
etc. attributes. This feature fills the gap left by a lack of support for polymorphic
functors and "with" kinds.

The most common use case for modality templates is to make a functor take portable input
modules to a portable output module, and nonportable input modules to a nonportable output
module. As such, there's an additional short-hand for doing so:

<!--
dummy modules for example below

```ocaml
module type S1 = sig end
module type S2 = sig end
module type S3 = sig end

module%template.portable F' (_ : S1) (_ : S2) : S3 = struct end
```
-->

```ocaml
module _ : sig
  (* In a signature *)
  module%template.portable F (X1 : S1) (X2 : S2) : S3
end = struct
  (* In a structure *)
  module%template.portable [@modality m] F (X1 : S1) (X2 : S2) : S3 = struct
    include F' [@modality m] (X1) (X2)
  end
end
```

Tricks and short hands
----------------------

One may find themselves needing to "lift" OCaml constructs not generated via this ppx to
have a mangled name compatible with the ppx. We strongly encourage users to do this via
the ppx, rather than mangling names themselves, as this may be brittle or even incorrect.

**WE DO NOT GUARANTEE STABILITY OF THE MANGLING ALGORITHM AT THIS TIME.**

Instead, a trick for this is to write a binding which is polymorphic over exactly one
kind - for example, to bind `Float` and `Float__float64` modules, one might write:

```ocaml
module%template [@kind __ = value] Float = Float (* alternatively, [@@kind __ = value] *)
module%template [@kind __ = float64] Float = Float_u
```

Here, `__` is just an identifier, nothing special, but seems like a good way to indicate
that a given kind variable is unused in the body of the binding.

There is even some syntax sugar:
```ocaml
module%template [@kind value] Float = Float (* alternatively, [@@kind value] *)
module%template [@kind float64] Float = Float_u
```

Extending this idea, one could even use a kind-polymorphic module binding to generate
kind-polymorphic bindings for many functions at once, as a kind of functor over kinds:

```ocaml
module%template [@kind k = (value, float64)] Make = struct
  open Float [@kind k]

  let[@kind k] of_string = of_string
  let[@kind k] to_string = to_string

  (* .. *)
end

include%template Make [@kind value]
include%template Make [@kind float64]
```

This too is common enough that we provide a shorthand:

```ocaml
include%template [@kind k = (value, float64)] struct
  open Float [@kind k]

  let[@kind k] of_string = of_string
  let[@kind k] to_string = to_string

  (* .. *)
end
```

The top-level `[@@@kind k = (a, b), ...]` attribute can be used to avoid explicitly
wrapping everything in `struct`/`sig` `end`, and is equivalent to wrapping all following
code within the same module in `include [@kind k = (a, b), ...] struct ... end`. So the
example from above can again be rewritten as:

```ocaml
[%%template
[@@@kind k = (value, float64)]

open Float [@kind k]

let[@kind k] of_string = of_string
let[@kind k] to_string = to_string

(* .. *)]
```

To avoid having to write `[@kind k]` on every binding in scope, you can use `[@@@kind.default]`,
which will automatically add `[@kind k]` to each binding that omits an explicit annotation:

```ocaml
[%%template
[@@@kind.default k = (value, float64)]

(* Note that since this isn't a binding, the [@kind] attribute is necessary. *)
open Float [@kind k]

let of_string = of_string
let to_string = to_string

(* .. *)]
```

which translates to

```ocaml
include struct
  open Float

  let of_string = of_string
  let to_string = to_string
end

include struct
  open Float__float64

  let of_string__float64 = of_string
  let to_string__float64 = to_string
end
```

The [%template] extension
-------------------------

This ppx is opt-in; that is, one must be inside of an `[%template]` extension point to use
the attributes. This is fairly generous in practice:

- `[%template <expression>]` in expression context
- `[%template: <type>]` in type context
- `[%template <structure>]` in module expression context
- `[%template: <signature>]` in module type context
- `[%%template <structure_item>]` in structure item context
- `[%%template: <signature_item>]` in signature item context

Constructs like `var%template` and `fun%template` are just built-in OCaml syntax sugar for
`[%%template var]` and `[%template fun]`, and so these work to turn on the ppx.

Type and module substitutions
-----------------------------

Type substitutions (using `:=`) are generally supported, but can sometimes get dropped due
to scoping issues. In particular, `ppx_template` may wrap certain constructs inside a
`include sig ... end`, and type substitutions are only visible to the immediately
enclosing signature. For example, these are fine:

```ocaml
module type%template A = sig
  [@@@kind.default k = (bits64, float64)]

  type ('a : k) t := 'a
  type nonrec 'a t = 'a t [@kind k]
end

module type B = sig
  type%template ('a : k) t := 'a [@@kind k = (bits64, float64)]
  type%template nonrec 'a t = 'a t [@kind k] [@@kind k = (bits64, float64)]
end
```

But this is not:

```ocaml
module type C = sig
  [%%template:
  [@@@kind.default k = (bits64, float64)]

  type ('a : k) t := 'a]

  type%template nonrec 'a t = 'a t [@kind k] [@@kind k = (bits64, float64)]
end
```
```mdx-error
Line 7, characters 36-37:
Error: Unbound type constructor t__bits64
```

Module type substitutions are supported, but are more constrained by the limitation
described above. This is fine:

```ocaml
module type%template A = sig
  [@@@kind.default k = (bits64, float64)]

  module type S := sig end
  module type S = S [@kind k]
end
```

But these are not:

```ocaml
module type B = sig
  module type%template S := sig end [@@kind k = (bits64, float64)]
  module type%template S = S [@kind k] [@@kind k = (bits64, float64)]
end
```
```mdx-error
Line 3, characters 30-31:
Error: Unbound module type S__bits64
```

```ocaml
module type C = sig
  [%%template:
  [@@@kind.default k = (bits64, float64)]

  module type S := sig end]

  module type%template S = S [@kind k] [@@kind k = (bits64, float64)]
end
```
```mdx-error
Line 7, characters 30-31:
Error: Unbound module type S__bits64
```

Module substitutions are not supported due to missing support for attributes in the
necessary locations.

Type variables vs. locally abstract types
-----------------------------------------

The ppx may behave unexpectedly when using type variables in `let` bindings. Take, for
example, the following identity function template:

```ocaml
let%template[@kind k = (value, float64)] f (x : ('a : k)) : 'a = x
```
```mdx-error
Line 1, characters 49-57:
Error: This type ('a : float64) should be an instance of type ('a0 : value)
       The layout of 'a is value
         because of the annotation on the type variable 'a.
       But the layout of 'a must overlap with float64
         because of the annotation on the type variable 'a.
```

Due to the way that type variables unify across function declarations in the same block,
this currently leads to an error.

To fix this, it's recommended you use locally abstract types instead of type variables
when ranging over multiple kinds:

```ocaml
let%template[@kind k = (value, float64)] f (type (a : k)) (x : a) : a = x
```

Further examples
----------------

See the [unboxed_float_example](unboxed_float_example.mdx) for a more thorough example.
